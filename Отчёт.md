# Лабораторная работа №7. Сервисы и Broadcast Receivers.

## Цели
Получить практические навыки разработки сервисов (started и bound) и Broadcast Receivers.

## Задачи
### Задача 1. Started сервис для скачивания изображения
В [лабораторной работе №6](../06/TASK.md) был разработан код, скачивающий картинку из интернета. На основе этого кода разработайте started service, скачивающий файл из интернета. URL изображения для скачивания должен передаваться в Intent. Убедитесь (и опишите доказательство в отчете), что код для скачивания исполняется не в UI потоке

Добавьте в разработанный сервис функцию отправки broadcast сообщения по завершении скачивания. Сообщение (Intent) должен содержать путь к скачанному файлу.

### Задача 2. Broadcast Receiver
Разработайте два приложения: первое приложение содержит 1 activity с 1 кнопкой, при нажатии на которую запускается сервис по скачиванию файла. Второе приложение содержит 1 broadcast receiver и 1 activity. Broadcast receiver по получении сообщения из сервиса инициирует отображение *пути* к изображению в `TextView` в Activity.

### Задача 3. Bound Service для скачивания изображения
Сделайте разработанный сервис одновременно bound И started: переопределите метод `onBind`. Из тела метода возвращайте `IBinder`, полученный из класса [`Messenger`](https://developer.android.com/guide/components/bound-services?hl=ru#Messenger). Убедитесь (доказательство опишите в отчете), что код скачивания файла исполняется не в UI потоке.

Измените способ запуска сервиса в первом приложении: вместо `startService` используйте `bindService`. При нажатии на кнопку отправляйте сообщение [`Message`](https://developer.android.com/reference/android/os/Message.html?hl=ru), используя класс `Messenger`, полученный из интерфейса `IBinder` в методе [`onServiceConnected`](https://developer.android.com/reference/android/content/ServiceConnection.html?hl=ru#onServiceConnected(android.content.ComponentName,%20android.os.IBinder)).

Добавьте в первое приложение `TextView`, а в сервис отправку [обратного](https://developer.android.com/reference/android/os/Message.html?hl=ru#replyTo) сообщения с местоположением скачанного файла. При получении сообщения от сервиса приложение должно отобразить путь к файлу на экране.

Обратите внимание, что разработанный сервис должен быть одновременно bound И started. Если получен интент через механизм started service, то сервис скачивает файл и отправляет broadcast (started service не знает своих клиентов и не предназначен для двухсторонней коммуникации). Если получен message через механизм bound service, то скачивается файл и результат отправляется тому клиенту, который запросил этот файл (т.к. bound service знает всех своих клиентов и может им отвечать).

## Выполнение работы

### Задача 1

Были задействованы материалы http://developer.alexanderklimov.ru/android/theory/intentservice.php , https://itsobes.ru/AndroidSobes/chto-takoe-intentservice-jobintentservice/ , https://developer.android.com/reference/androidx/core/app/JobIntentService, https://androidwave.com/working-with-jobintentservice/ ,
http://developer.alexanderklimov.ru/android/catshop/bitmap.php

Будем использовать JobIntentService так как он судя по документации , всегда выполняет операции в фоновом потоке.

ImageDownloadService

Обработка url происходит в onHandleWork, там в зависимости от того был ли передан url либо посылаем в бродкаст сообщение об ошибке, либо скачиваем изображение.Если url не null, 
то вызываем download, в котором на основе кода из 6ой лабораторной, создаём bitmap по url и передаём его в save, где уже и сохраняем файл. По документации JobIntentService должен выполняться в фоновом потоке, но для проверки запросим имя потока, в котором выполняется наша задача.Результаты будут приведены в разделе задачи 2.

```java
package com.example.androidlab7;

import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.core.app.JobIntentService;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;

public class ImageDownloadService extends JobIntentService {
    static final int JOB_ID = 1000;

    @Override
    protected void onHandleWork(@NonNull Intent intent) {
        String url = intent.getStringExtra("url");
        Log.d("thread", Thread.currentThread().getName());
        if (url == null) {
            sendBroadcast("Error");
        } else {
            try {
                String path = download(url);
                sendBroadcast(path);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    static void enqueueWork(Context context, Intent work) {
        enqueueWork(context, ImageDownloadService.class, JOB_ID, work);
    }

    public String download(String url) throws IOException {
        Bitmap mIcon11 = null;
        String path = null;
        try {
            InputStream in = new java.net.URL(url).openStream();
            mIcon11 = BitmapFactory.decodeStream(in);
            path = save(mIcon11, "test");
        } catch (MalformedURLException e) {
            e.printStackTrace();
        }
        return path;
    }

    public String save(Bitmap bitmap, String name) {
        FileOutputStream Stream;
        try {
            Stream = this.getApplicationContext().openFileOutput(name, Context.MODE_PRIVATE);
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, Stream);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        return getApplicationContext().getFileStreamPath(name).getAbsolutePath();
    }

    public void sendBroadcast(String message) {
        sendBroadcast(new Intent("broadcast").putExtra("Message", message));
    }
}

```
Добавим в манифест сервис
```xml
<service
            android:name="ImageDownloadService"
            android:permission="android.permission.BIND_JOB_SERVICE" />
```


## Задача 2
Задействованы материалы https://developer.android.com/reference/android/content/BroadcastReceiver

Тут просто пишем 2 приложения : одно по нажатию на кнопку скачивает сообщение, другое с бродкаст ресивером, по нажатию на кнопку пишет путь изображения в textView , заодно проверяем, что сервис действительно работает в фоновом потоке, а не в основном.

объявлять broadcast receiver будем путем регистрации экземпляра с помощью registerReceive

```java
package com.example.androidlab7;

import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.JobIntentService;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.util.Log;
import android.view.View;

import com.example.androidlab7.databinding.ActivityMainBinding;

public class MainActivity extends AppCompatActivity {
    ActivityMainBinding binding;
    BroadcastReceiver br;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        binding = ActivityMainBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());
         br = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                String message= intent.getStringExtra("Message");
                binding.textView.setText(message);
            }
        };
        registerReceiver(br, new IntentFilter("broadcast"));
        binding.button.setOnClickListener(
                new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        Log.d("thread", Thread.currentThread().getName());
                        Intent intent = new Intent(MainActivity.this, ImageDownloadService.class).putExtra("url", "https://wallbox.ru/wallpapers/preview/201432/8b74eb4d1393499.jpg");
                        ImageDownloadService.enqueueWork(MainActivity.this,intent);
                    }
                });
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregisterReceiver(br);
    }
}

```

```java
package com.example.androidlab7;

import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;

import androidx.appcompat.app.AppCompatActivity;

import com.example.androidlab7.databinding.ActivityMainBinding;

public class MainActivity2 extends AppCompatActivity {
    ActivityMainBinding binding;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        binding = ActivityMainBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());
        binding.button.setOnClickListener(
                new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        Log.d("thread", Thread.currentThread().getName());
                        Intent intent = new Intent(MainActivity2.this, ImageDownloadService.class).putExtra("url", "https://wallbox.ru/wallpapers/preview/201432/8b74eb4d1393499.jpg");
                        ImageDownloadService.enqueueWork(MainActivity2.this,intent);
                    }
                });
    }

}
```

Для начала подтвердим в каком потоке работает сервис:

По нажатию на кнопку, видим что выводятся имена  2х разных потоков main и AsyncTask #1(в нём и выполняется скачивание)

![](https://github.com/SukhachevN/AndroidLab7/blob/main/img/logcat.png)

Так как вариант без broadcast receiver визуально ничего не меняет, так как не получаем бродкаст сообщения, то демонстрировать работу будем на приложении с bradcasrt receiver

До нажатия на кнопку

![](https://github.com/SukhachevN/AndroidLab7/blob/main/img/before.png)


После нажатия на кнопку, видим путь, по которому расположена картинка

![](https://github.com/SukhachevN/AndroidLab7/blob/main/img/after.png)
